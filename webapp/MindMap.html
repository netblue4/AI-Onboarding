<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AI Compliance Mind Map - Fixed</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #f8fafc; margin: 0; overflow: hidden; }
        #controls { position: absolute; top: 20px; left: 20px; z-index: 10; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1); border: 1px solid #e2e8f0; max-width: 260px; }
        .node circle { cursor: pointer; stroke-width: 2.5px; }
        .node text { font-size: 11px; pointer-events: none; fill: #334155; }
        .link { fill: none; stroke: #cbd5e1; stroke-width: 1.5px; }
        
        /* Compliance Styles */
        .node-regulation circle { fill: #dbeafe; stroke: #1e40af; }
        .node-requirement circle { fill: #fef08a; stroke: #a16207; }
        .node-risk circle { fill: #fee2e2; stroke: #b91c1c; }
        .node-plan circle { fill: #dcfce7; stroke: #15803d; }
        .node-control circle { fill: #f1f5f9; stroke: #475569; }

        .tooltip { position: absolute; padding: 10px; background: #1e293b; color: white; border-radius: 6px; font-size: 12px; pointer-events: none; max-width: 300px; z-index: 20; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.2); line-height: 1.4; }
        .legend-item { display: flex; align-items: center; font-size: 11px; margin-bottom: 5px; }
        .legend-color { width: 10px; height: 10px; border-radius: 50%; margin-right: 8px; border: 1px solid #333; }
    </style>
</head>
<body>

<div id="controls">
    <h3 style="margin:0 0 10px 0; font-size:14px; color:#1e40af;">AI Act Gap Analyzer</h3>
    <div class="legend">
        <div class="legend-item"><div class="legend-color" style="background:#dbeafe"></div> Field Group</div>
        <div class="legend-item"><div class="legend-color" style="background:#fef08a"></div> Requirement</div>
        <div class="legend-item"><div class="legend-color" style="background:#fee2e2"></div> Risk</div>
        <div class="legend-item"><div class="legend-color" style="background:#dcfce7"></div> Test Plan</div>
        <div class="legend-item"><div class="legend-color" style="background:#f1f5f9"></div> Tech Control</div>
    </div>
    <p style="font-size: 10px; color: #64748b; margin-top: 10px;">• Click nodes to toggle<br>• Drag to pan<br>• Scroll to zoom</p>
</div>

<div id="mindmap"></div>

<script>
// --- YOUR DATA EMBEDDED ---
const rawData = {
  "1. Compliance Requirements": [
    {
      "StepName": "Article 13: Transparency and Provision of Information to Deployers",
      "Fields": [
        { "jkType": "fieldGroup", "jkName": "Transparency", "Role": "Compliance", "controls": [
            { "requirement_control_number": "[18229-1.1]", "jkName": "Intended Purpose", "jkText": "Clear, documented declaration...", "jkType": "requirement" },
            { "requirement_control_number": "[18229-1.2]", "jkName": "Limitations", "jkText": "Documentation of known blind spots...", "jkType": "requirement" }
        ]}
      ]
    }
    // ... I've truncated the data for this code block, but the script 
    // logic below processes your full multi-step structure.
  ],
  "2. Define": [], "3. Build": [], "4. Test": [], "5. Comply": [], "6. Approvals": [], "7. Deployment": [], "8. Operations": []
};

// NOTE: Since the full JSON is too large for the message window, 
// I've written the logic to work with the data structure you provided.
// REPLACE the rawData object above with your FULL JSON content.

let i = 0, root;
const width = window.innerWidth, height = window.innerHeight;
const treeLayout = d3.tree().nodeSize([40, 280]);
const svg = d3.select("#mindmap").append("svg")
    .attr("width", width).attr("height", height)
    .call(d3.zoom().on("zoom", (e) => g.attr("transform", e.transform)))
    .append("g");
const g = svg.append("g").attr("transform", `translate(150, ${height/2})`);
const tooltip = d3.select("body").append("div").attr("class", "tooltip").style("opacity", 0);

function processData(data) {
    const hierarchy = { name: "AI Compliance Root", type: "root", children: [] };
    const reqLookup = new Map();

    // Pass 1: Extract FieldGroups and Requirements
    Object.values(data).flat().forEach(step => {
        if (!step.Fields) return;
        step.Fields.forEach(group => {
            if (group.jkType === 'fieldGroup') {
                const groupNode = { name: group.jkName, type: 'regulation', details: group.Role, children: [] };
                hierarchy.children.push(groupNode);
                if (group.controls) {
                    group.controls.forEach(ctrl => {
                        if (ctrl.jkType === 'requirement') {
                            const node = { id: ctrl.requirement_control_number, name: ctrl.jkName, type: 'requirement', details: ctrl.jkText, children: [] };
                            groupNode.children.push(node);
                            reqLookup.set(ctrl.requirement_control_number, node);
                        }
                    });
                }
            }
        });
    });

    // Pass 2: Link Risks/Plans/Fields
    Object.values(data).flat().forEach(step => {
        if (!step.Fields) return;
        step.Fields.forEach(item => {
            if (item.requirement_control_number && item.jkType !== 'requirement') {
                const targets = String(item.requirement_control_number).split(',').map(s => s.trim());
                targets.forEach(t => {
                    if (reqLookup.has(t)) {
                        const impl = { name: item.jkName || "Link", type: item.jkType === 'risk' ? 'risk' : 'plan', details: item.RiskDescription || item.PlanObjective, children: [] };
                        if (item.controls) {
                            item.controls.forEach(c => impl.children.push({ name: c.control_number || c.jkName, type: 'control', details: c.jkText }));
                        }
                        reqLookup.get(t).children.push(impl);
                    }
                });
            }
        });
    });
    return hierarchy;
}

function update(source) {
    const nodes = treeLayout(root).descendants();
    const links = treeLayout(root).links();
    nodes.forEach(d => d.y = d.depth * 280);

    const node = g.selectAll('g.node').data(nodes, d => d.id || (d.id = ++i));
    const nodeEnter = node.enter().append('g')
        .attr('class', d => `node node-${d.data.type}`)
        .attr('transform', d => `translate(${source.y0 || 0}, ${source.x0 || 0})`)
        .on('click', (e, d) => {
            if (d.children) { d._children = d.children; d.children = null; }
            else { d.children = d._children; d._children = null; }
            update(d);
        })
        .on('mouseover', (e, d) => {
            tooltip.transition().duration(200).style("opacity", .9);
            tooltip.html(`<strong>${d.data.name}</strong><br/>${d.data.details || ''}`)
                .style("left", (e.pageX + 15) + "px").style("top", (e.pageY - 20) + "px");
        })
        .on('mouseout', () => tooltip.transition().style("opacity", 0));

    nodeEnter.append('circle').attr('r', 1e-6);
    nodeEnter.append('text').attr("dy", ".35em").attr("x", d => d.children || d._children ? -12 : 12)
        .attr("text-anchor", d => d.children || d._children ? "end" : "start").text(d => d.data.name);

    const nodeUpdate = nodeEnter.merge(node);
    nodeUpdate.transition().duration(400).attr('transform', d => `translate(${d.y}, ${d.x})`);
    nodeUpdate.select('circle').attr('r', 7).style("fill", d => d._children ? "#475569" : "#fff");

    node.exit().transition().duration(400).attr('transform', d => `translate(${source.y}, ${source.x})`).remove();

    const link = g.selectAll('path.link').data(links, d => d.target.id);
    const linkEnter = link.enter().insert('path', 'g').attr('class', 'link')
        .attr('d', d => { const o = {x: source.x0 || 0, y: source.y0 || 0}; return diagonal(o, o); });
    linkEnter.merge(link).transition().duration(400).attr('d', d => diagonal(d.source, d.target));
    link.exit().transition().duration(400).attr('d', d => { const o = {x: source.x, y: source.y}; return diagonal(o, o); }).remove();

    nodes.forEach(d => { d.x0 = d.x; d.y0 = d.y; });
}

function diagonal(s, t) {
    return `M ${s.y} ${s.x} C ${(s.y + t.y) / 2} ${s.x}, ${(s.y + t.y) / 2} ${t.x}, ${t.y} ${t.x}`;
}

// Initial Run
const hierarchyData = processData(rawData);
root = d3.hierarchy(hierarchyData);
root.children.forEach(c => { if(c.children) { c._children = c.children; c.children = null; } });
update(root);

</script>
</body>
</html>