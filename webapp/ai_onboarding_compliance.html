<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Regulatory Risk & Implementation Mapping</title>
    <style>
        :root {
            --primary-color: #2563eb;
            --secondary-color: #475569;
            --bg-light: #f8fafc;
            --border-color: #e2e8f0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #334155;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--bg-light);
        }

        h1 {
            color: #1e293b;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 10px;
        }

        #loading, #error {
            padding: 20px;
            font-size: 1.2em;
        }
        #error { color: #dc2626; }

        .mapping-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            padding: 25px;
            margin-top: 20px;
        }

        .reg-item {
            margin-bottom: 25px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
        }

        .reg-header {
            background-color: #eff6ff;
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .reg-title {
            font-size: 1.1em;
            font-weight: 700;
            color: #1e40af;
            margin: 0;
        }

        .reg-meta {
            font-size: 0.9em;
            color: var(--secondary-color);
            margin-top: 5px;
        }

        .imp-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .imp-item {
            padding: 12px 20px;
            border-bottom: 1px solid var(--bg-light);
            display: flex;
            align-items: flex-start;
        }

        .imp-item:last-child {
            border-bottom: none;
        }

        .imp-type-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: 600;
            text-transform: uppercase;
            margin-right: 10px;
            min-width: 50px;
            text-align: center;
        }

        .type-risk { background-color: #fee2e2; color: #991b1b; }
        .type-plan { background-color: #dcfce7; color: #166534; }

        .imp-content {
            flex: 1;
        }

        .imp-title {
            font-weight: 500;
        }

        .imp-meta {
            font-size: 0.85em;
            color: #64748b;
            margin-top: 2px;
        }

        .no-children {
            padding: 15px 20px;
            color: var(--secondary-color);
            font-style: italic;
        }
    </style>
</head>
<body>

    <h1>Regulatory Compliance to Implementation Mapping</h1>
    
    <div id="loading">Loading onboarding procedure data...</div>
    <div id="error" style="display: none;"></div>
    <div id="content" class="mapping-container" style="display: none;"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const loadingEl = document.getElementById('loading');
            const errorEl = document.getElementById('error');
            const contentEl = document.getElementById('content');

            fetch('ai_onboarding_procedure_data.json')
                .then(response => {
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    return response.json();
                })
                .then(data => {
                    processAndRenderData(data);
                    loadingEl.style.display = 'none';
                    contentEl.style.display = 'block';
                })
                .catch(err => {
                    loadingEl.style.display = 'none';
                    errorEl.textContent = `Error loading data: ${err.message}. Please ensure 'ai_onboarding_procedure_data.json' is in the same directory.`;
                    errorEl.style.display = 'block';
                });
        });

        /**
         * Helper function to check if a field's TrustDimension contains a specific tag.
         * @param {object} field - The field node to check.
         * @param {string} dimension - The dimension tag to look for (e.g., "Requirement").
         * @returns {boolean}
         */
        function hasTrustDimension(field, dimension) {
            if (!field || !field.TrustDimension || typeof field.TrustDimension !== 'string') {
                return false;
            }
            // Split by comma, trim whitespace, and check for exact match
            return field.TrustDimension.split(',').map(s => s.trim()).includes(dimension);
        }

        function processAndRenderData(webappData) {
            // 1. Flatten all steps and extract all fields
            let allFields = [];
            Object.values(webappData).flat().forEach(step => {
                if (step.Fields && Array.isArray(step.Fields)) {
                    allFields = allFields.concat(step.Fields);
                }
            });

            // 2. Separate nodes into Requirements (Parents) and Implementations (Children)
            const requirementNodes = [];
            const implementationNodes = [];

            allFields.forEach(field => {
                // Check for the "Requirement" tag
                if (hasTrustDimension(field, 'Requirement')) {
                    requirementNodes.push(field);
                } 
                // A node can be an implementation if it's a 'risk' or 'plan'
                // and (implicitly) does not have the 'Requirement' tag (handled by else if)
                else if (['risk', 'plan'].includes(field.FieldType)) {
                    implementationNodes.push(field);
                }
            });

            // 3. Build compliance map, keyed by the Requirement's Control ID
            // Map<string, { parentField: object, children: Set<object> }>
            const complianceMap = new Map();
            requirementNodes.forEach(reqNode => {
                if (!reqNode.Control) return; // Skip requirements without a control ID
                
                // Use the reqNode.Control as the key
                if (!complianceMap.has(reqNode.Control)) {
                    complianceMap.set(reqNode.Control, {
                        parentField: reqNode,
                        children: new Set()
                    });
                }
            });

            // 4. Link Implementations (Children) to Requirements (Parents)
            implementationNodes.forEach(implNode => {
                if (!implNode.Control) return; // This implementation can't be linked
                
                // Split the implementation's control string (e.g., "[Art-12][Par-3], [A.5.6]")
                const implControlParts = implNode.Control.split(',').map(s => s.trim());

                // Check against every Requirement (parent) in our map
                complianceMap.forEach((reqData, reqControlKey) => {
                    
                    // Check if any part of the implementation's control list
                    // contains the requirement's (parent's) control key
                    const isLinked = implControlParts.some(part => part.includes(reqControlKey));

                    if (isLinked) {
                        // Yes, this implementation is a child of this requirement
                        reqData.children.add(implNode);
                    }
                });
            });

            // 5. Render the results (this function is unchanged from previous version)
            renderMapping(complianceMap);
        }

        function renderMapping(complianceMap) {
            const container = document.getElementById('content');
            container.innerHTML = '';

            let hasMatches = false;

            // Convert Map to array and sort by Control ID for cleaner display
            const sortedEntries = Array.from(complianceMap.entries()).sort((a, b) => a[0].localeCompare(b[0]));

            sortedEntries.forEach(([controlKey, data]) => {
                // We will display all Requirements, even if they have no children,
                // to show what is defined.
                // To only show items with children, uncomment the next line:
                // if (data.children.size === 0) return;

                hasMatches = true;
                const parent = data.parentField;

                const regItem = document.createElement('div');
                regItem.className = 'reg-item';

                // --- Regulatory Node Header ---
                const header = document.createElement('div');
                header.className = 'reg-header';
                header.innerHTML = `
                    <div class="reg-title">${escapeHtml(parent.FieldName)}</div>
                    <div class="reg-meta"><strong>Control:</strong> ${escapeHtml(parent.Control)} | <strong>Trust Dimension:</strong> ${escapeHtml(parent.TrustDimension || 'N/A')}</div>
                `;
                regItem.appendChild(header);

                // --- Implementation Children List ---
                const impList = document.createElement('ul');
                impList.className = 'imp-list';

                if (data.children.size === 0) {
                    const noChildren = document.createElement('div');
                    noChildren.className = 'no-children';
                    noChildren.textContent = 'No matching implementation risks or plans found.';
                    impList.appendChild(noChildren);
                } else {
                    // Convert Set to Array and sort children by their Control for consistent ordering
                    const sortedChildren = Array.from(data.children).sort((a, b) => (a.Control || '').localeCompare(b.Control || ''));

                    sortedChildren.forEach(child => {
                        const impItem = document.createElement('li');
                        impItem.className = 'imp-item';

                        const typeClass = child.FieldType === 'risk' ? 'type-risk' : 'type-plan';
                        
                        impItem.innerHTML = `
                            <span class="imp-type-badge ${typeClass}">${escapeHtml(child.FieldType)}</span>
                            <div class="imp-content">
                                <div class="imp-title">${escapeHtml(child.FieldName)}</div>
                                <div class="imp-meta">
                                    <strong>Matches Control:</strong> ${escapeHtml(child.Control)}
                                    ${child.Role ? ` | <strong>Role:</strong> ${escapeHtml(child.Role)}` : ''}
                                </div>
                            </div>
                        `;
                        impList.appendChild(impItem);
                    });
                }

                regItem.appendChild(impList);
                container.appendChild(regItem);
            });

            if (!hasMatches) {
                container.innerHTML = '<p>No "Requirement" nodes found in the data. Please check the JSON file for fields with "Requirement" in their TrustDimension.</p>';
            }
        }

        // Utility to prevent HTML injection from JSON data
        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return unsafe;
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }
    </script>
</body>
</html>
