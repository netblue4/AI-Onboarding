<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Onboarding Procedure 222</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <h1 id="main-title">Loading...</h1>
        <div id="form-container"></div>

        <div class="button-container">
            <button id="prev-btn" style="display: none;">Previous</button>  
            <button id="next-btn">Next</button>
            <button id="download-btn" style="display: none;">Download JSON</button>
        </div>
    </div>
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // Fetch the external JSON data from the 'webappData.json' file
        fetch('ai_onboarding_procedure_data.json')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Network response was not ok: ${response.statusText}`);
                }
                return response.json();
            })
            .then(webappData => {
                // The rest of the application logic is now placed inside this .then() block,
                // ensuring it only runs after the data has been successfully loaded.
                
                const formContainer = document.getElementById('form-container');
                const prevBtn = document.getElementById('prev-btn'); // New Previous Button
                const nextBtn = document.getElementById('next-btn');
                const downloadBtn = document.getElementById('download-btn');
                const mainTitle = document.getElementById('main-title');

                const capturedData = {};
                const procedureSteps = Object.keys(webappData);
                let currentStepIndex = 0;

                // Sanitizes a string to be used as a valid HTML ID.
                function sanitizeForId(text) {
                    if (typeof text !== 'string') return '';
                    return text.replace(/[^a-zA-Z0-9_]/g, '_');
                }

                // Renders the current step of the form based on the currentStepIndex.
                function renderCurrentStep() {
                    const stepKey = procedureSteps[currentStepIndex];
                    const stepData = webappData[stepKey];
                    
                    if (!stepData) {
                        mainTitle.textContent = "Error";
                        formContainer.innerHTML = "<p>Could not find data for the current step. Please check the data source.</p>";
                        return;
                    }

                    // --- Button Visibility Logic ---
                    prevBtn.style.display = currentStepIndex > 0 ? 'inline-block' : 'none';
                    nextBtn.style.display = 'inline-block';
                    downloadBtn.style.display = 'none';

                    mainTitle.textContent = stepData.WebFormTitle || "Procedure Step";
                    formContainer.innerHTML = ''; 

                    const formStepDiv = document.createElement('div');
                    formStepDiv.className = 'form-step';

                    if (!stepData.Fields || stepData.Fields.length === 0 || !stepData.Fields[0].FieldName) {
                         const note = document.createElement('p');
                         note.textContent = "This is a procedural note or a decision point. Click 'Next' to continue.";
                         formStepDiv.appendChild(note);
                    } else {
                        stepData.Fields.forEach(field => {
                            if (!field || !field.FieldName) return;
                            
                            const fieldDiv = document.createElement('div');
                            fieldDiv.className = 'form-field';
                            const sanitizedId = sanitizeForId(field.FieldName);

                            if (field.FieldType === 'Auto generated number') {
                                const label = document.createElement('label');
                                label.textContent = field.FieldLabel + ': ';
                                const span = document.createElement('span');
                                span.className = 'auto-generated-label';
                                // Use existing value if available, otherwise generate new
                                const uniqueId = capturedData[field.FieldName] || 'AutoGen_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
                                span.textContent = uniqueId;
                                fieldDiv.appendChild(label);
                                fieldDiv.appendChild(span);
                                capturedData[field.FieldName] = uniqueId;
                            } else if (field.FieldType === 'TextBox') {
                                const input = document.createElement('textarea');
                                input.id = sanitizedId;
                                input.name = sanitizedId;
                                input.placeholder = field.FieldLabel;
                                input.rows = 3;
                                input.value = capturedData[field.FieldName] || ''; // Restore captured data
                                fieldDiv.appendChild(input);
                            } else if (field.FieldType && field.FieldType.startsWith('Dropdown box with values')) {
                                // Check if FieldLabel exists and is a string
                                if (field.FieldLabel && typeof field.FieldLabel === 'string') {
                                    // Split the label text by the "||" delimiter
                                    const multiline = field.FieldLabel.split('||');
                                    // Loop through each line of text
                                    multiline.forEach(lineText => {
                                        // Create a new label for each line
                                        const label = document.createElement('label');
                                        label.setAttribute('for', sanitizedId);
                                        label.textContent = lineText.trim(); // Use the trimmed line of text
                                        // Add a class for CSS styling (to make it display on a new line)
                                        label.classList.add('multiline-label'); 
                                        
                                        // If it's the first item in the array (index is 0), make it bold
                                        if (index === 0) {
                                             label.classList.add('label-bold');
                                        }
                                        
                                        // Add the new label to your container
                                        fieldDiv.appendChild(label);
                                    });
                                } else {
                                    // (Optional) Handle cases where FieldLabel is missing or not text
                                    // For example, you could create a single, default label
                                    const label = document.createElement('label');
                                    label.setAttribute('for', sanitizedId);
                                    // Use the FieldName as a fallback, or a default message
                                    label.textContent = field.FieldName || 'Label not available'; 
                                    fieldDiv.appendChild(label);
                                }
                                const select = document.createElement('select');
                                select.id = sanitizedId;
                                select.name = sanitizedId;                                
                                const optionsString = field.FieldType.split(':')[1]?.trim() || '';
                                const options = optionsString.split('/');
                                
                                options.forEach(optionText => {
                                    const option = document.createElement('option');
                                    option.value = optionText.trim();
                                    option.textContent = optionText.trim();
                                    select.appendChild(option);
                                });
                                select.value = capturedData[field.FieldName] || options[0].trim(); // Restore captured data
                                fieldDiv.appendChild(select);
                            }
                            formStepDiv.appendChild(fieldDiv);
                        });
                    }
                    formContainer.appendChild(formStepDiv);
                }

                // Event listener for the 'Previous' button.
                prevBtn.addEventListener('click', () => {
                    if (currentStepIndex > 0) {
                        currentStepIndex--;
                        renderCurrentStep();
                    }
                });

                // Event listener for the 'Next' button.
                nextBtn.addEventListener('click', () => {
                    const currentStepKey = procedureSteps[currentStepIndex];
                    const stepData = webappData[currentStepKey];

                    if (stepData && stepData.Fields) {
                        stepData.Fields.forEach(field => {
                            if (field && field.FieldName && field.FieldType !== 'Auto generated number') {
                                const sanitizedId = sanitizeForId(field.FieldName);
                                const inputElement = document.getElementById(sanitizedId);
                                if (inputElement) {
                                    capturedData[field.FieldName] = inputElement.value;
                                }
                            }
                        });
                    }

                    currentStepIndex++;
                    if (currentStepIndex < procedureSteps.length) {
                        renderCurrentStep();
                    } else {
                        formContainer.innerHTML = '<h2>Onboarding procedure completed!</h2><p>You can now download the generated JSON file containing all your input.</p>';
                        mainTitle.textContent = "Finished";
                        nextBtn.style.display = 'none';
                        prevBtn.style.display = 'none'; // Hide on final screen
                        downloadBtn.style.display = 'block';
                    }
                });

                // Event listener for the 'Download' button.
                downloadBtn.addEventListener('click', () => {
                    const jsonData = JSON.stringify(capturedData, null, 4);
                    const blob = new Blob([jsonData], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'onboarding_documentation.json';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                });

                // Initial render of the first step.
                renderCurrentStep();
            })
            .catch(error => {
                console.error('Error loading the webapp data:', error);
                mainTitle.textContent = "Error";
                formContainer.innerHTML = "<p>Failed to load procedure data. Please check the console for errors and ensure 'webappData.json' is available in the same directory.</p>";
            });
    });
    </script>
</body>
</html>
